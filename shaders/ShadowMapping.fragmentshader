#version 330 core

in vec4 vertex_position_cameraspace;
in vec4 vertex_normal_cameraspace;
in vec4 light_position_cameraspace;
in vec2 vertex_UV;
in vec4 vertex_position_lightspace;
           
in vec3 frag_position_world;

uniform sampler2D shadowMapSampler;
uniform sampler2D diffuseColorSampler;
uniform sampler2D specularColorSampler;
uniform sampler2D dudvSampler;

uniform int useTexture; // 0-> terrain, 1->house, 
                        // 2-> water, 3->classic, 
                        // 4->glitter, 5->metallic, 
                        // 6->neon, 7->transparent, 
                        // 8->3D texture

// task 1: make river flow
uniform float time;
//task 5: beacon
uniform int isBeacon;

// light properties
struct Light {
    vec4 La;
    vec4 Ld;
    vec4 Ls;
    vec3 lightPosition_worldspace;
};
uniform Light light;

// materials
struct Material {
    vec4 Ka; 
    vec4 Kd;
    vec4 Ks;
    float Ns; 
};
uniform Material mtl;

out vec4 fragmentColor;


void phong(float visibility);
float ShadowCalculation(vec4 fragPositionLightspace);
vec3 computeWorldNormal();

//
// balloon effects

// glitter - Procedural sparkles
float glitterEffect(vec3 worldPos, float time) {
    // Multi-scale noise για realistic sparkles
    vec3 p1 = worldPos * 15.0;
    vec3 p2 = worldPos * 25.0;
    
    // Hash function για pseudo-random sparkles
    float n1 = fract(sin(dot(p1, vec3(12.9898, 78.233, 45.164))) * 43758.5453);
    float n2 = fract(sin(dot(p2, vec3(63.7264, 10.873, 623.6))) * 43758.5453);
    
    // Animated sparkles που twinkle
    float sparkle1 = step(0.985, n1 + 0.015 * sin(time * 8.0 + n1 * 100.0));
    float sparkle2 = step(0.99, n2 + 0.01 * sin(time * 12.0 + n2 * 150.0));
    
    return max(sparkle1, sparkle2 * 0.7);
}

// metallic reflection
vec3 metallicReflection(vec3 normal, vec3 viewDir) {
    // Calculate reflection vector
    vec3 reflectDir = reflect(-viewDir, normal);
    
    // Fake sky/environment gradient
    float skyFactor = reflectDir.y * 0.5 + 0.5;
    vec3 skyColor = mix(vec3(0.4, 0.5, 0.7), vec3(0.8, 0.9, 1.0), skyFactor);
    
    // Fake ground reflection
    vec3 groundColor = vec3(0.3, 0.25, 0.2);
    vec3 envColor = mix(groundColor, skyColor, smoothstep(-0.2, 0.5, reflectDir.y));
    
    return envColor;
}

// neon glow effect
vec3 neonGlow(vec3 baseColor, vec3 normal, vec3 viewDir) {
    // fresnel για rim lighting effect
    float fresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), 3.5);
    
    // pulsating glow
    float pulse = 0.8 + 0.2 * sin(time * 3.0);
    
    // emissive glow color
    vec3 glowColor = baseColor * 2.5 * pulse;
    
    return mix(baseColor, glowColor, fresnel * 0.9);
}

// 3D (procedural) Texture - bumpy surface
vec3 proceduralPattern(vec3 worldPos, vec3 baseColor) {
    // vertical stripes
    float stripes = sin(worldPos.y * 18.0) * 0.5 + 0.5;
    stripes = smoothstep(0.3, 0.7, stripes);
    
    // circular bumps
    vec3 p = fract(worldPos * 5.0) - 0.5;
    float bumps = length(p);
    bumps = smoothstep(0.25, 0.45, bumps);
    
    // combine
    float pattern = mix(stripes, bumps, 0.5);
    
    // apply to base color
    return baseColor * (0.6 + pattern * 0.8);
}

// beacon animated patterns
vec3 beaconPattern(vec2 uv, vec3 baseColor, float time) {
    // Moving rings pattern
    float ringPattern = sin((uv.y * 15.0 - time * 3.0) * 3.14159);
    ringPattern = smoothstep(0.2, 0.8, ringPattern);
    
    // Pulsating brightness
    float pulse = 0.7 + 0.3 * sin(time * 2.0);
    
    // Golden glow color
    vec3 glowColor = vec3(1.0, 0.9, 0.3);
    
    // Mix base color with glowing pattern
    vec3 patternColor = mix(baseColor, glowColor, ringPattern * pulse * 0.7);
    
    return patternColor;
}

void main() {   
    // Shadow calculation
    float shadow = ShadowCalculation(vertex_position_lightspace);
    float visibility = 1.0 - shadow;

    phong(visibility);
}


float ShadowCalculation(vec4 fragPositionLightspace) {
    float shadow;
    
    // Perspective divide
    vec3 projCoords = vertex_position_lightspace.xyz / vertex_position_lightspace.w;
    projCoords = 0.5 * projCoords + 0.5;

    float closestDepth = texture(shadowMapSampler, projCoords.xy).r;
    float currentDepth = projCoords.z;

    // Bias to fix shadow acne
    float bias = 0.005;
    
    // PCF for soft shadows
    shadow = 0.0;
    vec2 depthMap_dimensions = textureSize(shadowMapSampler, 0);
    vec2 texelSize = 1.0 / depthMap_dimensions;
    for(int x = -1; x <= 1; x++ ){
        for(int y = -1; y <= 1; y++ ){
            float pcfDepth = texture(shadowMapSampler, projCoords.xy + vec2(x, y) * texelSize).r;
            shadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;
        }
    }
    shadow /= 9.0;

    if(projCoords.z > 1)
        shadow = 0.0;
        
    return shadow;
}


void phong(float visibility) {
    vec2 uv = vertex_UV;
    
    vec4 _Ks = mtl.Ks;
    vec4 _Kd = mtl.Kd;
    vec4 _Ka = mtl.Ka;
    float _Ns = mtl.Ns;
    
    // Vectors for lighting
    vec4 N = normalize(vertex_normal_cameraspace);
    vec4 L = normalize(light_position_cameraspace - vertex_position_cameraspace);
    vec4 V = normalize(-vertex_position_cameraspace); // View direction

    // house texture
    if (useTexture == 1) {
        _Ks = vec4(texture(specularColorSampler, vertex_UV).rgb, 1.0);
        _Kd = vec4(texture(diffuseColorSampler, vertex_UV).rgb, 1.0);
        _Ka = vec4(0.05 * _Kd.rgb, _Kd.a);
        _Ns = 10;
    }

    // water
    if (useTexture == 2) {
        vec2 dudvUV = vec2(vertex_UV.x, vertex_UV.y + time * 0.05);
        vec2 distortion = texture(dudvSampler, dudvUV).rg;
        distortion = distortion * 2.0 - 1.0;
        distortion *= 0.08;

        vec2 noiseUV = vertex_UV * 3.0;
        noiseUV.y += time * 0.015;
        vec2 noise = texture(dudvSampler, noiseUV).rg;
        noise = noise * 2.0 - 1.0;
        noise *= 0.015;

        vec2 totalDistortion = distortion + noise;
        vec2 distortedUV = vertex_UV + totalDistortion;
        vec3 baseColor = texture(diffuseColorSampler, distortedUV).rgb;
        
        N = normalize(vec4(totalDistortion.x, 1.0, totalDistortion.y, 0.0));

        float fresnel = pow(1.0 - max(dot(V, N), 0.0), 3.0);

        vec3 deepWater = vec3(0.0, 0.18, 0.35);
        vec3 shallowWater = vec3(0.2, 0.5, 0.7);
        vec3 waterColor = mix(deepWater, shallowWater, fresnel);

        _Kd = vec4(baseColor * mix(0.6, 1.0, fresnel), 0.8);
        _Ka = vec4(waterColor * 0.3, 0.8);
        _Ks = vec4(vec3(1.0), 1.0);
        _Ns = mix(40.0, 160.0, fresnel);
    }

    // classic BALLOON
    if (useTexture == 3) {
        N = vec4(computeWorldNormal(), 0.0);
    }

    // Standard Phong calculation
    vec4 Ia = light.La * _Ka;
    
    float cosTheta = clamp(dot(N, L), 0, 1);
    vec4 Id = light.Ld * _Kd * cosTheta;
    
    vec4 R = reflect(-L, N);
    vec4 E = normalize(vec4(0, 0, 0, 1) - vertex_position_cameraspace);
    float cosAlpha = clamp(dot(E, R), 0, 1);
    float specular_factor = pow(cosAlpha, _Ns);
    vec4 Is = light.Ls * _Ks * specular_factor;

    // Base color
    fragmentColor = vec4(
        Ia + 
        Id * visibility + 
        Is * visibility
    );

    // balloom effects
    
    // glitter BALLOON (useTexture == 4)
    if (useTexture == 4) {
        vec3 worldNormal = computeWorldNormal();
        vec3 viewDir = normalize(-vertex_position_cameraspace.xyz);

        // fresnel - rim lighting (fixing 3D depth)
        float fresnel = pow(1.0 - max(dot(worldNormal, viewDir), 0.0), 2.5); 
        // boost base color for brightness
        fragmentColor.rgb *= 1.4;
        // rim highlight
        fragmentColor.rgb += vec3(0.3, 0.25, 0.3) * fresnel;

        float glitter = glitterEffect(frag_position_world, time);
        // sparkles
        fragmentColor.rgb += vec3(glitter * 1.2);
        // Extra shine στα sparkles
        if (glitter > 0.5) {
            fragmentColor.rgb += vec3(0.3, 0.3, 0.4) * glitter;

        }
    }
    
    // metallic BALLOON (useTexture == 5)
    else if (useTexture == 5) {
        vec3 worldNormal = computeWorldNormal();
        vec3 viewDir = normalize(-vertex_position_cameraspace.xyz);
        vec3 metallic = metallicReflection(worldNormal, viewDir);
        
        // Mix base color and metallic reflection
        fragmentColor.rgb = mix(fragmentColor.rgb, metallic, 0.7);
        
        // extra specular for chrome effect
        fragmentColor.rgb += vec3(0.2) * specular_factor;
    }
    
    // neon BALLOON (useTexture == 6)
    else if (useTexture == 6) {
        vec3 worldNormal = computeWorldNormal();
        vec3 viewDir = normalize(-vertex_position_cameraspace.xyz);
        
        // neon glow effect
        vec3 neonColor = neonGlow(_Kd.rgb, worldNormal, viewDir);
        fragmentColor.rgb = neonColor;
        
        // emissive boost - glows even in the dark
        fragmentColor.rgb += _Kd.rgb * 0.4;
    }
    
    // transparent BALLOON (useTexture == 7)
    else if (useTexture == 7) {
        // glass-like effect
        vec3 worldNormal = computeWorldNormal();
        vec3 viewDir = normalize(-vertex_position_cameraspace.xyz);
        // fresnel effect for glass edges
        float fresnel = pow(1.0 - max(dot(worldNormal, viewDir), 0.0), 2.0);
        
        // transparency using rim-lighting
        fragmentColor.a = 0.25 + fresnel * 0.3;
        fragmentColor.rgb = mix(fragmentColor.rgb, vec3(1.0), fresnel * 0.4);
    }
    
    // 3D textured BALLOON (useTexture == 8)
    else if (useTexture == 8) {
        vec3 patternColor = proceduralPattern(frag_position_world, _Kd.rgb);
        fragmentColor.rgb = mix(fragmentColor.rgb, patternColor, 0.8);
        // bump-like shading
        vec3 p = fract(frag_position_world * 5.0) - 0.5;
        float bump = length(p);
        fragmentColor.rgb *= (0.9 + bump * 0.2);
    }

    // water opacity
    if (useTexture == 2) {
        fragmentColor.a = 0.8; 
    }
    // BEACON effect
    if (isBeacon == 1) {
        // Apply animated patterns to beacon surface
        fragmentColor.rgb = beaconPattern(vertex_UV, fragmentColor.rgb, time);
        
        // Pulsating transparency for extra glow effect
        float pulse = 0.7 + 0.3 * sin(time * 2.0);
        fragmentColor.a = 0.6 + 0.2 * pulse;
    }
}

vec3 computeWorldNormal() {
    vec3 dx = dFdx(frag_position_world);
    vec3 dy = dFdy(frag_position_world);
    return normalize(cross(dx, dy));
}